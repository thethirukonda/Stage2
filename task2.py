# -*- coding: utf-8 -*-
"""Task2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y9cMmG1RGjrAvZQUlyuYYwZOg4tXOI11

# Step 1
installing all necessary packages here
"""

!pip install scanpy
!pip install anndata
!pip install igraph
!pip install celltypist
!pip install decoupler

import scanpy as sc
import anndata as ad
import pandas as pd
import decoupler as dc

"""#Step 2
Getting data from the *source*
"""

#now we load the dataset

!wget https://github.com/josoga2/sc/raw/refs/heads/main/bone_marrow.h5ad

bone_marrow_adata = sc.read('/content/bone_marrow.h5ad')

print (bone_marrow_adata)

print (bone_marrow_adata.shape)

# Just to insepect few things

bone_marrow_adata.obs.head(3)
bone_marrow_adata.var.head(3)

"""#Step 3
Fix gene names
"""

bone_marrow_adata.var_names = bone_marrow_adata.var['feature_name'].astype(str)

bone_marrow_adata.var_names_make_unique()

bone_marrow_adata.var_names



""" The dataset from CZI uses ensemble gene ids. This is in contradiction to what decoupler expects.This block downloads a mapping table and converts PanglaoDB markers to Ensembl IDs so decoupler enrichment works correctly.

"""

!wget wget -O result.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "CSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "hsapiens_gene_ensembl" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "external_gene_name" /></Dataset></Query>'


#this downloads the table of genes directly from ensemble

import pandas as pd

ensembl_var = pd.read_csv('/content/result.txt', header = None)

ensembl_var.columns = ['ensembl_gene_id', 'gene_name']

ensembl_var.head(3)

# Query Omnipath and get PanglaoDB
markers = dc.op.resource(name="PanglaoDB", organism="human")

# Keep canonical cell type markers alone
#markers = markers[markers["canonical_marker"]]

# Remove duplicated entries
markers = markers[~markers.duplicated(["cell_type", "genesymbol"])]

#Format because dc only accepts cell_type and genesymbol

markers = markers.rename(columns={"cell_type": "source", "genesymbol": "target"})
markers = markers[["source", "target"]]


markers.head()

#correct target to ensemble
markers = markers.merge(ensembl_var, left_on="target", right_on="gene_name", how="left")
markers = markers.drop(columns=["target"])
# Remove duplicated entries
markers = markers[~markers.duplicated(["source", "ensembl_gene_id"])]

#Format because dc only accepts cell_type and genesymbol
markers = markers.rename(columns={"source": "source", "ensembl_gene_id": "target"})

markers = markers[["source", "target"]]
markers = markers.dropna()

markers.head()

"""To check var meta data, which contains genes (variables)- you can see meta data , and some realted info to gene- like no of cells, type of gene etc """
bone_marrow_adata.var.head()

#Convert to DF
bone_marrow_adata.to_df()

#Removing duplicates from var and obs- this is just a good practice for older datasets, nothing else
bone_marrow_adata.var_names_make_unique()
bone_marrow_adata.obs_names_make_unique()

print(bone_marrow_adata.obs.columns)

"""# Step 4-Quality Control
Cells with a high proportion of mitochondrial reads (say >10–20%) are likely stressed, apoptotic, or poorly captured.

Think about this- we extract those cells into a micrifludic device, there is a good chance that it may some stress

you can find ribosome everywhere, why would you need them when you study cell specific ?

Instead of true cell populations, high HB signal often represents ambient RNA contamination from lysed red blood cells
Search of contamination from dying cells (MT, mitochondrial genes), ribosomal transcripts (RIBO) or hemoglobin (HB).

The thresholds are: (MT < 5%, RB < 10%, and HB < 5%).
"""

#Obtaining MT,Ribo,Hb from Var,
bone_marrow_adata.var['MT'] = bone_marrow_adata.var['feature_name'].str.startswith("MT-")
bone_marrow_adata.var['RIBO'] = bone_marrow_adata.var['feature_name'].str.startswith(("RPS", "RPL"))
bone_marrow_adata.var['HB'] = bone_marrow_adata.var['feature_name'].str.contains("^HB[^(P)]", regex=True)

mt_genes=bone_marrow_adata.var[bone_marrow_adata.var['MT']]
print(mt_genes.head(2))
ribo_genes=bone_marrow_adata.var[bone_marrow_adata.var['RIBO']]
print(ribo_genes.head(2))
hb_genes=bone_marrow_adata.var[bone_marrow_adata.var['HB']]
print(hb_genes.head(2))

"""Calculating QC"""

sc.pp.calculate_qc_metrics(
    bone_marrow_adata, qc_vars=["MT", 'RIBO', 'HB'], inplace=True, log1p=True
)

#Violin Plots
sc.pl.violin(
    bone_marrow_adata,
    ["n_genes_by_counts", "total_counts", "pct_counts_MT"],
    jitter=0.4,
    multi_panel=True,
)

sc.pl.scatter(
    bone_marrow_adata,
    x="total_counts",
    y="n_genes_by_counts",
    color=["pct_counts_MT", "pct_counts_RIBO", "pct_counts_HB"]
)

"""All three plots show a nice diagonal relationship:
it means

*  Cells with more sequencing depth detect more genes (expected)
*   No weird clusters or outliers

*   Linear relationship is maintained


So no filtering



"""

#doublet detection
##Identifying doublets is crucial as they can lead to misclassifications or
##distortions in downstream analysis steps
sc.pp.scrublet(bone_marrow_adata)

"""# Step 5 Normalisation

we do normalisation because some samples may be sequenced at more depth, so we do that to adjusts for sequencing depth differences between cells. Here, we scale counts so each cell has the same total expression level.
"""

# Save a copy of the data
bone_marrow_adata.layers["counts"] = bone_marrow_adata.X.copy()

# Normalizing to median total counts
sc.pp.normalize_total(bone_marrow_adata)
# Logarithmize the data
sc.pp.log1p(bone_marrow_adata)

#Feature selection
#selecting the top 1000 most variable genes
sc.pp.highly_variable_genes(bone_marrow_adata, n_top_genes=1000)

#plotting 1000
sc.pl.highly_variable_genes(bone_marrow_adata)

"""#Step 6 Dimensionality reduction
PCA compresses this high-dimensional data into a smaller set of features (typically 30–50 components) that summarize the key biological and technical variation across cells.

Remember: you have ~2,000 highly variable genes in your dataset. Each gene is like a dimension.Imagine this scenario:

You want to plot your cells to see which ones are similar But you can't plot 2,000 dimensions on a screen! You need to compress the data down to 2-3 dimensions you can visualize The challenge: How do you compress 2,000 dimensions without losing the important patterns?PCA's answer: Find the directions where cells differ the most, and keep those.


"""

sc.tl.pca(bone_marrow_adata)

sc.pl.pca_variance_ratio(bone_marrow_adata, n_pcs=10, log=False)

"""PC1 = 14% This means: "If I could only draw ONE line through my data to capture the most variation, it would explain 14% of all the differences between cells." Why only 14%? Because cells are complex!

They don't all differ in just ONE way There are multiple cell types, multiple states, multiple sources of variation It takes MANY directions to capture all that complexity

PC2 = 4% The second-best direction only captures 4%. Why the big drop?

The MAIN source of variation was already captured by PC1 What's left is smaller, more subtle patterns

PC3, PC4, PC5... decreasing Each additional PC captures progressively less because:

#6 Clustering

Clustering by communities in single-cell RNA-seq is the process of grouping cells that show similar expression profiles — essentially, discovering putative cell types or states.
Once PCA compresses your data into a manageable set of dimensions, clustering algorithms like Leiden operate on a graph-based representation of cell–cell relationships.
Usually used for cell type detection
"""

sc.pp.neighbors(bone_marrow_adata)

sc.tl.umap(bone_marrow_adata)

sc.tl.leiden(bone_marrow_adata, flavor="igraph", n_iterations=2)
sc.pl.umap(
    bone_marrow_adata,
    color=["leiden"],
    size=8,
)

#Adjusting resolution
sc.tl.leiden(bone_marrow_adata, flavor="igraph", n_iterations=2, key_added="leiden_res0_3", resolution=0.3)

sc.pl.umap(
   bone_marrow_adata,
    color=["leiden_res0_3"],
    # increase horizontal space between panels
    wspace=0.5,
    size=15,
    ncols = 1
)

"""#step 7 Annontations
Cell annotation is the process of assigning biological meaning—like cell type or functional state—to each cluster found after Leiden clustering.

Traditionally, this relies on manual marker gene inspection: you identify top genes per cluster and match them to known markers. But tools like Decoupler enable a more systematic and data-driven approach.

Decoupler is a framework for gene set activity inference. Instead of labeling clusters by single markers, it estimates the activity of predefined pathways, transcription factors, or cell-type signatures from known databases (e.g., MSigDB, PROGENy, DoRothEA).

In practice:

You provide your normalized expression matrix (adata).

You load gene sets representing known biological programs or cell-type signatures.

Decoupler calculates an activity score per cell or cluster using methods like weighted mean, ULM, or AUCell.

You interpret those activities to annotate clusters automatically or semi-automatically.


"""

import decoupler as dc

# Simply reload markers with gene symbols (no Ensembl conversion)
markers = dc.op.resource(name="PanglaoDB", organism="human")

# Remove duplicated entries
markers = markers[~markers.duplicated(["cell_type", "genesymbol"])]

# Format - just rename columns, keep gene symbols
markers = markers.rename(columns={"cell_type": "source", "genesymbol": "target"})
markers = markers[["source", "target"]]
markers = markers.dropna()

print("Markers reloaded with gene symbols:")
print(markers.head())

# Check overlap
data_genes = set(bone_marrow_adata.var_names)
marker_genes = set(markers['target'])
overlap = data_genes.intersection(marker_genes)

print(f"\nOverlapping genes: {len(overlap)}")

# Now run ULM
dc.mt.ulm(data=bone_marrow_adata,
          net=markers)

print("\nSuccess! ULM scores are in: bone_marrow_adata.obsm['ulm_estimate']")

#retrieve the score for each cell type

score = dc.pp.get_obsm(bone_marrow_adata, key="score_ulm")
score

bone_marrow_adata.obsm["score_ulm"].head()

bone_marrow_adata.obsm["score_ulm"].columns

# Step 1: Copy clustering to score object
score.obs['leiden_res0_3'] = bone_marrow_adata.obs['leiden_res0_3']

# Step 2: Rank cell types for each cluster
bone_marrow_rank = dc.tl.rankby_group(
    score,
    groupby="leiden_res0_3",  # ← Use leiden_res0_3
    reference="rest",
    method="t-test_overestim_var"
)

# Step 3: Filter for positive statistics
bone_marrow_rank = bone_marrow_rank[bone_marrow_rank["stat"] > 0]

# Step 4: Look at results
bone_marrow_rank.head(20)

# Step 5: Create cluster annotations automatically
cluster_annotations = bone_marrow_rank.groupby("group").head(1).set_index("group")["name"].to_dict()

# Step 6: Check what was created
print(cluster_annotations)

# Step 7: Apply annotations
bone_marrow_adata.obs['cell_type'] = bone_marrow_adata.obs['leiden_res0_3'].map(cluster_annotations)

# Step 8: Visualize annotated clusters
sc.pl.umap(bone_marrow_adata, color='cell_type', legend_loc='right margin', frameon=False)

bone_marrow_adata_rank = dc.tl.rankby_group(score, groupby="leiden_res0_3", reference="rest", method="t-test_overestim_var")
bone_marrow_adata_rank = bone_marrow_adata_rank[bone_marrow_adata_rank["stat"] > 0]
bone_marrow_adata_rank.head()

# Filter for positive statistics first
bone_marrow_rank_filtered = bone_marrow_rank[bone_marrow_rank["stat"] > 0]

# Then create cluster annotations
cluster_annotations = bone_marrow_rank_filtered.groupby("group").head(1).set_index("group")["name"].to_dict()

print(cluster_annotations)

cluster_annotations

# Get available genes
available_genes = set(bone_marrow_adata.var_names)

# Extract markers for each cell type from your current annotations

# Neutrophils
neutrophil_markers = markers[markers['source'].isin(['Neutrophils'])]['target']
neutrophil_markers = neutrophil_markers[neutrophil_markers.isin(available_genes)]

# Gamma delta T cells
gamma_delta_markers = markers[markers['source'].isin(['Gamma delta T cells'])]['target']
gamma_delta_markers = gamma_delta_markers[gamma_delta_markers.isin(available_genes)]

# T memory cells
t_memory_markers = markers[markers['source'].isin(['T memory cells'])]['target']
t_memory_markers = t_memory_markers[t_memory_markers.isin(available_genes)]

# NK cells
nk_markers = markers[markers['source'].isin(['NK cells'])]['target']
nk_markers = nk_markers[nk_markers.isin(available_genes)]

# B cells naive
b_naive_markers = markers[markers['source'].isin(['B cells naive'])]['target']
b_naive_markers = b_naive_markers[b_naive_markers.isin(available_genes)]

# Platelets
platelet_markers = markers[markers['source'].isin(['Platelets'])]['target']
platelet_markers = platelet_markers[platelet_markers.isin(available_genes)]

# Plasma cells
plasma_markers = markers[markers['source'].isin(['Plasma cells'])]['target']
plasma_markers = plasma_markers[plasma_markers.isin(available_genes)]

# Monocytes
monocyte_markers = markers[markers['source'].isin(['Monocytes'])]['target']
monocyte_markers = monocyte_markers[monocyte_markers.isin(available_genes)]

# Check how many markers found for each
print("Markers found:")
print(f"Neutrophils: {len(neutrophil_markers)}")
print(f"Gamma delta T cells: {len(gamma_delta_markers)}")
print(f"T memory cells: {len(t_memory_markers)}")
print(f"NK cells: {len(nk_markers)}")
print(f"B cells naive: {len(b_naive_markers)}")
print(f"Platelets: {len(platelet_markers)}")
print(f"Plasma cells: {len(plasma_markers)}")
print(f"Monocytes: {len(monocyte_markers)}")

# Check how many clusters got annotations
print("Total clusters:", bone_marrow_adata.obs['leiden_res0_3'].nunique())
print("Annotated cell types:", bone_marrow_adata.obs['cell_type'].nunique())

# Check if any clusters are missing annotations (NaN values)
missing = bone_marrow_adata.obs['cell_type'].isna().sum()
print(f"Cells without annotation: {missing}")

# See which clusters got which cell types
cluster_to_celltype = bone_marrow_adata.obs.groupby('leiden_res0_3')['cell_type'].first()
print("\nCluster → Cell Type mapping:")
print(cluster_to_celltype)

# Count cells per cell type
print("\nCells per cell type:")
print(bone_marrow_adata.obs['cell_type'].value_counts())

# Get available genes
available_genes = set(bone_marrow_adata.var_names)

# Extract markers for each cell type
neutrophil_markers = markers[markers['source'] == 'Neutrophils']['target']
neutrophil_markers = neutrophil_markers[neutrophil_markers.isin(available_genes)]

gamma_delta_markers = markers[markers['source'] == 'Gamma delta T cells']['target']
gamma_delta_markers = gamma_delta_markers[gamma_delta_markers.isin(available_genes)]

t_memory_markers = markers[markers['source'] == 'T memory cells']['target']
t_memory_markers = t_memory_markers[t_memory_markers.isin(available_genes)]

nk_markers = markers[markers['source'] == 'NK cells']['target']
nk_markers = nk_markers[nk_markers.isin(available_genes)]

b_naive_markers = markers[markers['source'] == 'B cells naive']['target']
b_naive_markers = b_naive_markers[b_naive_markers.isin(available_genes)]

platelet_markers = markers[markers['source'] == 'Platelets']['target']
platelet_markers = platelet_markers[platelet_markers.isin(available_genes)]

plasma_markers = markers[markers['source'] == 'Plasma cells']['target']
plasma_markers = plasma_markers[plasma_markers.isin(available_genes)]

monocyte_markers = markers[markers['source'] == 'Monocytes']['target']
monocyte_markers = monocyte_markers[monocyte_markers.isin(available_genes)]

# Print what we found
print(f"Neutrophils: {len(neutrophil_markers)} markers - {neutrophil_markers.head().tolist()}")
print(f"Gamma delta T cells: {len(gamma_delta_markers)} markers - {gamma_delta_markers.head().tolist()}")
print(f"T memory cells: {len(t_memory_markers)} markers - {t_memory_markers.head().tolist()}")
print(f"NK cells: {len(nk_markers)} markers - {nk_markers.head().tolist()}")
print(f"B cells naive: {len(b_naive_markers)} markers - {b_naive_markers.head().tolist()}")
print(f"Platelets: {len(platelet_markers)} markers - {platelet_markers.head().tolist()}")
print(f"Plasma cells: {len(plasma_markers)} markers - {plasma_markers.head().tolist()}")
print(f"Monocytes: {len(monocyte_markers)} markers - {monocyte_markers.head().tolist()}")

# Create marker dictionary
marker_genes_dict = {
    "Neutrophils": ['ADAM8', 'ADPGK', 'ARG2', 'ASPRV1', 'AZU1'],
    "Gamma delta T cells": ['ADGRG1', 'ASPM', 'AURKB', 'BIRC5', 'CCL5'],
    "T memory cells": ['ACP5', 'APBB1IP', 'ARHGAP15', 'ARHGAP45', 'ARHGEF1'],
    "NK cells": ['AHR', 'CCL3', 'CCL4', 'CCL5', 'CD2'],
    "B cells naive": ['ABCB4', 'ADAM28', 'BACH2', 'BANK1', 'BCL7A'],
    "Platelets": ['ABCA3', 'ABCC4', 'ACKR3', 'ADAM10', 'ADGRE5'],
    "Plasma cells": ['ABCB9', 'CCR10', 'CD19', 'CD24', 'CD27'],
    "Monocytes": ['ACE', 'ACP5', 'ADA2', 'ADGRE1', 'APOBEC3A']
}

# Create dotplot - add use_raw=False to use the filtered genes
sc.pl.dotplot(bone_marrow_adata,
              marker_genes_dict,
              groupby='cell_type',
              dendrogram=True,
              figsize=(14, 8),
              use_raw=False)  # ← This is the fix!